{
  parserClass="org.example.minicobolparser.parser.MiniCobolParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="MiniCobol"
  psiImplClassSuffix="Impl"

  psiPackage="org.example.minicobolparser.psi"
  psiImplPackage="org.example.minicobolparser.psi.impl"

  elementTypeHolderClass="org.example.minicobolparser.psi.MiniCobolTypes"
  elementTypeClass="org.example.minicobolparser.psi.MiniCobolElementType"
  tokenTypeClass="org.example.minicobolparser.psi.MiniCobolTokenType"
}

miniCobolFile ::= cobolLine*

private cobolLine ::= LINE_NUMBER lineBody

lineBody ::= identificationDivisionHeader
           | programIdHeader
           | dataDivisionHeader
           | workingStorageSectionHeader
           | dataDescriptionEntry
           | procedureDivisionHeader
           | paragraphHeader
           | statementLine

identificationDivisionHeader ::= IDENTIFICATION DIVISION DOT
programIdHeader ::= PROGRAM_ID DOT IDENTIFIER DOT
dataDivisionHeader ::= DATA DIVISION DOT
workingStorageSectionHeader ::= WORKING_STORAGE SECTION DOT
procedureDivisionHeader ::= PROCEDURE DIVISION DOT

paragraphHeader ::= IDENTIFIER DOT

dataDescriptionEntry ::= INTEGER IDENTIFIER pictureClause dataValueClause? DOT
dataValueClause ::= VALUE literal

/* picture-clause = ( "PICTURE" | "PIC" ) [ "IS" ] picture-string */
pictureClause ::= (PIC | PICTURE) IS? pictureString

/* picture-string = currency? (picchar+ repeat?)+ (punctuation (picchar+ repeat?)+)* */
pictureString ::= CURRENCY? pictureGroup+ (PUNCTUATION pictureGroup+)*

pictureGroup ::= picChar+ repeat?
picChar ::= PICCHAR
repeat ::= LPAREN INTEGER RPAREN

statementLine ::= performStatement | stopStatement | displayStatement

performStatement ::= PERFORM IDENTIFIER performVaryingPhrase DOT?
performVaryingPhrase ::= performTestPhrase? VARYING IDENTIFIER FROM performFrom BY performBy UNTIL condition
performTestPhrase ::= WITH? TEST (BEFORE | AFTER)

performFrom ::= IDENTIFIER | literal
performBy ::= IDENTIFIER | literal

stopStatement ::= STOP (RUN | literal) DOT?

displayStatement ::= DISPLAY displayOperand+ displayUponPhrase? displayAdvancingPhrase? DOT?
displayOperand ::= IDENTIFIER | literal
displayUponPhrase ::= UPON IDENTIFIER
displayAdvancingPhrase ::= WITH? NO ADVANCING

literal ::= INTEGER | STRING

condition ::= combinableCondition ((AND | OR) combinableCondition)*
combinableCondition ::= NOT? simpleCondition

simpleCondition ::= relationCondition | LPAREN condition RPAREN
relationCondition ::= arithmeticExpression relationalOperator arithmeticExpression
arithmeticExpression ::= IDENTIFIER | INTEGER

relationalOperator ::= IS? (
      (NOT? (GREATER THAN? | GT | LESS THAN? | LT | EQUAL TO? | EQ))
    | (GREATER THAN? OR EQUAL TO?)
    | GE
    | (LESS THAN? OR EQUAL TO?)
    | LE
    | (LT EQ)
)
